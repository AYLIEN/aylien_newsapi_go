/*
 * AYLIEN News API
 *
 * The AYLIEN News API is the most powerful way of sourcing, searching and syndicating analyzed and enriched news content. It is accessed by sending HTTP requests to our server, which returns information to your client. 
 *
 * API version: 3.0
 * Contact: support@aylien.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package newsapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// ClusterApiService ClusterApi service
type ClusterApiService service

// ListClustersOpts Optional parameters for the method 'ListClusters'
type ListClustersOpts struct {
    Id optional.Interface
    Id2 optional.Interface
    StoryCountMin optional.Int32
    StoryCountMax optional.Int32
    TimeStart optional.String
    TimeEnd optional.String
    EarliestStoryStart optional.String
    EarliestStoryEnd optional.String
    LatestStoryStart optional.String
    LatestStoryEnd optional.String
    LocationCountry optional.Interface
    LocationCountry2 optional.Interface
    Return_ optional.Interface
    SortBy optional.String
    SortDirection optional.String
    Cursor optional.String
    PerPage optional.Int32
}

/*
ListClusters List Clusters
The clusters endpoint is used to return clusters based on parameters you set in your query. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ListClustersOpts - Optional Parameters:
 * @param "Id" (optional.Interface of []int64) -  This parameter is used for finding clusters by cluster id. 
 * @param "Id2" (optional.Interface of []int64) -  This parameter is used for excluding clusters by cluster id. 
 * @param "StoryCountMin" (optional.Int32) -  This parameter is used for finding clusters with more than or equal to a specific amount of stories associated with them. 
 * @param "StoryCountMax" (optional.Int32) -  This parameter is used for finding clusters with less than or equal to a specific amount of stories associated with them. 
 * @param "TimeStart" (optional.String) -  This parameter is used for finding clusters whose creation time is greater than the specified value. [Here](https://newsapi.aylien.com/docs/working-with-dates) you can find more information about how [to work with dates](https://newsapi.aylien.com/docs/working-with-dates). 
 * @param "TimeEnd" (optional.String) -  This parameter is used for finding clusters whose creation time is less than the specified value. [Here](https://newsapi.aylien.com/docs/working-with-dates) you can find more information about how [to work with dates](https://newsapi.aylien.com/docs/working-with-dates). 
 * @param "EarliestStoryStart" (optional.String) -  This parameter is used for finding clusters whose publication date of its earliest story is greater than the specified value. [Here](https://newsapi.aylien.com/docs/working-with-dates) you can find more information about how [to work with dates](https://newsapi.aylien.com/docs/working-with-dates). 
 * @param "EarliestStoryEnd" (optional.String) -  This parameter is used for finding clusters whose publication date of its earliest story is less than the specified value. [Here](https://newsapi.aylien.com/docs/working-with-dates) you can find more information about how [to work with dates](https://newsapi.aylien.com/docs/working-with-dates). 
 * @param "LatestStoryStart" (optional.String) -  This parameter is used for finding clusters whose publication date of its latest story is greater than the specified value. [Here](https://newsapi.aylien.com/docs/working-with-dates) you can find more information about how [to work with dates](https://newsapi.aylien.com/docs/working-with-dates). 
 * @param "LatestStoryEnd" (optional.String) -  This parameter is used for finding clusters whose publication date of its latest story is less than the specified value. [Here](https://newsapi.aylien.com/docs/working-with-dates) you can find more information about how [to work with dates](https://newsapi.aylien.com/docs/working-with-dates). 
 * @param "LocationCountry" (optional.Interface of []string) -  This parameter is used for finding clusters belonging to a specific country. It supports [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country codes. [Here](https://newsapi.aylien.com/docs/working-with-locations) you can find more information about how [to work with locations](https://newsapi.aylien.com/docs/working-with-locations). 
 * @param "LocationCountry2" (optional.Interface of []string) -  This parameter is used for excluding clusters belonging to a specific country. It supports [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country codes. [Here](https://newsapi.aylien.com/docs/working-with-locations) you can find more information about how [to work with locations](https://newsapi.aylien.com/docs/working-with-locations). 
 * @param "Return_" (optional.Interface of []string) -  This parameter is used for specifying return fields.
 * @param "SortBy" (optional.String) -  This parameter is used for changing the order column of the results. You can read about sorting results [here](https://newsapi.aylien.com/docs/sorting-results). 
 * @param "SortDirection" (optional.String) -  This parameter is used for changing the order direction of the result. You can read about sorting results [here](https://newsapi.aylien.com/docs/sorting-results). 
 * @param "Cursor" (optional.String) -  This parameter is used for finding a specific page. You can read more about pagination of results [here](https://newsapi.aylien.com/docs/pagination-of-results). 
 * @param "PerPage" (optional.Int32) -  This parameter is used for specifying number of items in each page You can read more about pagination of results [here](https://newsapi.aylien.com/docs/pagination-of-results) 
@return Clusters
*/
func (a *ClusterApiService) ListClusters(ctx _context.Context, localVarOptionals *ListClustersOpts) (Clusters, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Clusters
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		t:=localVarOptionals.Id.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id[]", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Id2.IsSet() {
		t:=localVarOptionals.Id2.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("!id[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("!id[]", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.StoryCountMin.IsSet() {
		localVarQueryParams.Add("story_count.min", parameterToString(localVarOptionals.StoryCountMin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoryCountMax.IsSet() {
		localVarQueryParams.Add("story_count.max", parameterToString(localVarOptionals.StoryCountMax.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimeStart.IsSet() {
		localVarQueryParams.Add("time.start", parameterToString(localVarOptionals.TimeStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimeEnd.IsSet() {
		localVarQueryParams.Add("time.end", parameterToString(localVarOptionals.TimeEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EarliestStoryStart.IsSet() {
		localVarQueryParams.Add("earliest_story.start", parameterToString(localVarOptionals.EarliestStoryStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EarliestStoryEnd.IsSet() {
		localVarQueryParams.Add("earliest_story.end", parameterToString(localVarOptionals.EarliestStoryEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatestStoryStart.IsSet() {
		localVarQueryParams.Add("latest_story.start", parameterToString(localVarOptionals.LatestStoryStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatestStoryEnd.IsSet() {
		localVarQueryParams.Add("latest_story.end", parameterToString(localVarOptionals.LatestStoryEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationCountry.IsSet() {
		t:=localVarOptionals.LocationCountry.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("location.country", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("location.country", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.LocationCountry2.IsSet() {
		t:=localVarOptionals.LocationCountry2.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("!location.country", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("!location.country", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Return_.IsSet() {
		t:=localVarOptionals.Return_.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("return[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("return[]", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.SortBy.IsSet() {
		localVarQueryParams.Add("sort_by", parameterToString(localVarOptionals.SortBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortDirection.IsSet() {
		localVarQueryParams.Add("sort_direction", parameterToString(localVarOptionals.SortDirection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-AYLIEN-NewsAPI-Application-ID"] = key
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-AYLIEN-NewsAPI-Application-Key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Clusters
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
